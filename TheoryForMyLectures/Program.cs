using System;

namespace TheoryForMyLectures
{
    class Program
    {
        static void Main(string[] args)
        {
            //Да  ги добавя:

            //Друго предимство на Mock пред Fake е че в тестовете Arrange частта става по - ясна (сетнатите неща ги виждаме в теста, а не са в друг клас).
            //Също така в проекта липсват иначе излишните Fake файлове, които ако са повече стават проблем.

            //Test Driven Development TDD най - якото на TDD е че ни позволява да разберем за проблеми в дизайна
            //(които може да са свързани със бизнес заданието, логиката) на ранен етап. Да ходиш по вода и да пишеш код по бизнес спецификация
            //е лесно ако и двете са замразени.
            //С TDD разбираме още в началото дали имаме дупки в бизнес заданието, логиката и намалява вероятността за грешка.
            //Друг + е че самите тестове ще са по изчерпателни и добри. 80-90 % code coverage is perfect!

            //Рядко се налага да тестваме дали нещо печати по конзолата, но ако се наложи трябва да си направим абстракция с IWriter.
            //TDD ни помага да се справим с написването на по-сложен код, като ни показва къде са ни грешките докато го пишем!

            //Peer Review го има във всяка компания и е проверка от някой синиер преди кода да се пусне в продъкшън,
            //като взависимост от компанията може да е място където научаваш много или място където се заяждат.

            //Callback прилича на Return, но Return връща ст-ст, а в Callback може да се подаде делегат, който да връща ст-ст - Стамо не е фен на това, защото допълнително може да
            //внесе несигурност!

            //TDD не е особено смислен за неща които са тривиялни, които са ни пределно ясни,
            //TDD обаче е много добър за по сложни и не съвсем ясни задачи - при такива ни помага да си ги изясним възможно на най-ранен етап и да
            //си намалим грешките, защото в момента в който започнем да пишем кода ще сме премислили задачата, условието (пишейки тестове) и картинката ще ни
            //е доста по-подредена отколкото ако директно се хвърлим да пишем кода.

            //Ако на Стамо се наложи да използва търсещ алгуритъм в приложението си би използвал ElasticSearch или със средствата на базата данни. Директна работа
            //с търсещи дървета почти не се налага, но веднъж знанията му по алгуритми и търсещи дървета са му спестили писането на 2500 стр. документация.





            //Ивайло Кенов - Functional in C# - Advanced Lecture:
            //public int MyProperty { get; init; } този init дава възможност за сетване само при инициализация иначе си е рийд онли пропърти!

            //Рекорди:
            //public record CatRecord(string name, int age) - rekord - a ни създава имютъбъл обекти и реално с този ред съзвадохме 
            //имютъбъл обект с конструктор изискващ съответните параметри, пропъртита с init; т.е. сетващи се само при инстанциране и деконструктор (който е от C# 7 - деконструктва обект на параметри(трябва да проуча що е то)).
            //В C# 9 много лесно можем да правим имютъбъл тайпс - това е още един функционален парадигъм. Това е мнодо удобно да обекти,
            //които са само данни(пропъртита).

            //От C# 9 имаме и ключовата думичка with, която ни позволява да клонираме обект, Пример:
            //var catRecord = new CatRecord("Sharo", 5);
            //var anotherRecordCat = catRecord with { Age = catRecord.Age + 1 }; яко е защото с това клониране създаваме нов обект буквално на един ред.
            //var (_, age) = anotherRecordCat; a това e deconstruktora казва дай ми пропъртитата на този обект.

            //Съществуват и имютъбъл колекции.

            //експрешън е функционалното заместване на иф елс конструкция с тернарен оператор например.
            //стейтмънт е иф елс проверките стандартно разписани.

            //експрешъна е за предпочитане пред стейтмънта, където има заделяне на променлива, промяната и връщането и, както и повече писане.
            //експрешъна е по-малко четим, но при добра подредба става, логичен е:
            //public static string GetSatExpression(int hour)
            //    => hour < 12
            //    ? "Good Morning"
            //    : "Good afternoon"; За такива прости примери това е супер, за по сложни може и да не е!

            //Функции от по- висок ред  (да подаваш във функция други функции като аргументи или функция да връща друга функция) доста мощни са Linq ги ползва и затова ни харесва!
            //Така лесно абстрактваме/изнасяме обща функционалност, което винаги е добре.
            //Функционални комозиции са по сложна материя.

            //Linq крие форичове и ифове които са характерни за по императивното писане.

            //императивното писане използва стейтманти;
            //декларативното(функционалното) използва експрешъни;

            //Много често Linq е по приятен и четим за стрейтфорлърд алгуритми (по простички)

            //Якото с функции от по-висок ред е че можем рън тайм да произвеждаме функции, които да подаваме на други функции
            // и става мощно сложничко и забавно!

            //Чейнинга на функции доста често се ползва при експрешъните - при декларативния подход.
            //Декларативния подход поощрява малкото блокове (ифове, форичи)

            //Where ToList() на практика са форич и ифове изнесени в метод и скрити от нас (подобни неща е добре и ние да правим)!

            //Тоест добва практика е да си изнасяме на методи форич и ифове -те и така кода ни става по декларативен и четим - когато метода е така кръстен че да не се налага да го отваряме и гледаме какво прави.

            //Това е и една от основните идеи на функционалното програмиране - кода да е компактен и лесно четим!

            //Как да постигнем стейт мутация (защото някъде нещо трябва да променим)- Правим апп -а ни с имютибъл кор(ядро) и мютъбъл шелл(мида, обвивка). По голямата част трябва да е имютъбъл, а мютъбъл частта да е максимално тъничкa.

            //!!!Да разгледам Indeavr постоянно търсели готини надъхани хора имащи желание за развитие - интересна и сериозна компания!
            //Mentormate също, много бързо развиваща се сериозна компания (650 души екип!)

            //Tuple (комбинация от ст-сти) - тюпъла е удобен и полезен  и се използва най-вече когато пишем по функционално на C#. 
            //За мен поне интересен пример за Tuple: (double sum, int count) tuple = (4.5, 3);
            //Подобно е на клас със пропъртита с разликата че се пише по бързо и удобно - за случаи където искаме лесно да комбинираме ст-сти, да ги добавяме или връщаме. 

            //Функционални техники:
            //Curring - Означава да разцепим функция на много малки функцийки с по един параметър.
            //Partial application е естественото продължение на Curring и означава да извикаме част от функцията.
            //Много е мощно и .Нет 5 го използва много, за дипенданси инджекшън например
            //Composition - да комбинираме много функции в една - постигаме го с екстеншъл методи и дженерици. Изглежда сложно (по дефиниция), но не е.
            //Създаваме такива само при нужда

            //Map/Select(от Linq) e едно и също! Select е имплементацията на МОНАД в C#!
            //FlatMap/SelectMany(от Linq) e едно и също!

            //.? този синтаксис заменя if (statement == null) return; !!!


            //Функционални абстракции - да изгледам филма Предестинейшън and Primer и тогава ще мога да разбера защо ИК трудно е зацепил това. Концепциите са по-странни
            //МОНАД патърн, позволява ни да чейнваме функции без да ги нестваме (чрез функцията .FlatMap).

            //При промяна на стейта на обект не ъпдейтваме настоящия а създаваме нов -
        }
    }
}
